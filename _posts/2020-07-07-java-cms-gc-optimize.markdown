---
layout: post
title:  "java cms gc 耗时分析并调优"
date:   2020-07-07 17:13:25 +0800
author: hdu.yang
---

## 起因
  * 来新公司后才开始使用 java 写代码，因此对于 java 这门新语言其实是边模仿变写的，其实学任何新语言最好的办法就是有一份比较高质量的代码可以参考。即便是再怎么参考别人的 java 代码，但是写服务的过程中避免不了会遇到 java 的 gc 问题，真正关注 java 的 gc 是从有一天晚上突然收到公司的告警，cms gc 的时间超过 500ms，然后上游大面积的报超时开始的。gc 其实也不是什么稀奇的玩意，目前大部分语言都会将 gc 设计进来，这对于写这门语言的人来说不需要太多关注内存的申请和释放过程。但是一般来说发生 gc 后很多人并不关心它，因为 gc 是一种正常的现象，而我却要关心它的原因在于我们的 java 程序是给别人提供 soa 服务的，而对方的请求是有超时时间的，如果 gc 的时间偏长，那么对方就会在这段时间内大量的报超时，影响用户体验。由于公司是用 java 的 cms gc 作为真正的 gc 算法的。

## 原理
  * 既然已经知道问题的起因，那就要先了解问题产生的原理，需要对 cms gc 的整个过程有一定的了解，否则就无从调优。一般 java 的 GC 分新生代和老年代 GC 两种，一般新生代的 GC 比较频繁，并且新生代的 GC 时间一般较短，一般在几十毫秒内，也就是说即使发生 gc，也不会对服务造成太大的影响。我们关注的主要是老年代的 GC，因为老年代的 GC 一旦发生并且耗时较长的话，对服务的影响是比较明显的，因此我们需要分析下老年代 GC 的过程中系统都做了什么事情。老年代 GC 过程中有两个阶段是 STW 的，一个是 Init mark，另一个是 remark，这两个步骤都是需要遍历整个内存堆栈的。Init mark 的过程是一个初步的标记，标记那些从 Root 往下的引用对象，remark 是一个复制清除的过程，执行真正的 gc 算法（具体的 gc 算法可以参考其他资料）
## 分析
  * 
## 解决
  * 
